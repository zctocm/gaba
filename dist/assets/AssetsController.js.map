{"version":3,"file":"AssetsController.js","sourceRoot":"","sources":["../../src/assets/AssetsController.ts"],"names":[],"mappings":"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","sourcesContent":["import { toChecksumAddress } from 'ethereumjs-util';\nimport BaseController, { BaseConfig, BaseState } from '../BaseController';\nimport PreferencesController from '../user/PreferencesController';\nimport NetworkController, { NetworkType } from '../network/NetworkController';\nimport { Token } from './TokenRatesController';\nimport { AssetsContractController } from './AssetsContractController';\nimport { safelyExecute, handleFetch, validateTokenToWatch } from '../util';\nimport { EventEmitter } from 'events';\nimport { ApiCollectibleResponse } from './AssetsDetectionController';\n\nconst Mutex = require('await-semaphore').Mutex;\nconst random = require('uuid/v1');\n\n/**\n * @type Collectible\n *\n * Collectible representation\n *\n * @property address - Hex address of a ERC721 contract\n * @property description - The collectible description\n * @property image - URI of custom collectible image associated with this tokenId\n * @property name - Name associated with this tokenId and contract address\n * @property tokenId - The collectible identifier\n */\nexport interface Collectible {\n\taddress: string;\n\tdescription?: string;\n\timage?: string;\n\tname?: string;\n\ttokenId: number;\n}\n\n/**\n * @type CollectibleContract\n *\n * Collectible contract information representation\n *\n * @property name - Contract name\n * @property logo - Contract logo\n * @property address - Contract address\n * @property symbol - Contract symbol\n * @property description - Contract description\n * @property totalSupply - Contract total supply\n */\nexport interface CollectibleContract {\n\tname?: string;\n\tlogo?: string;\n\taddress: string;\n\tsymbol?: string;\n\tdescription?: string;\n\ttotalSupply?: string;\n}\n\n/**\n * @type ApiCollectibleContractResponse\n *\n * Collectible contract object coming from OpenSea api\n *\n * @property description - The collectible identifier\n * @property image_url - URI of collectible image associated with this collectible\n * @property name - The collectible name\n * @property description - The collectible description\n * @property total_supply - Contract total supply\n */\nexport interface ApiCollectibleContractResponse {\n\tdescription?: string;\n\timage_url?: string;\n\tname?: string;\n\tsymbol?: string;\n\ttotal_supply?: string;\n}\n\n/**\n * @type CollectibleInformation\n *\n * Collectible custom information\n *\n * @property description - The collectible description\n * @property name - Collectible custom name\n * @property image - Image custom image URI\n */\nexport interface CollectibleInformation {\n\tdescription?: string;\n\timage?: string;\n\tname?: string;\n}\n\n/**\n * @type AssetsConfig\n *\n * Assets controller configuration\n *\n * @property networkType - Network ID as per net_version\n * @property selectedAddress - Vault selected address\n */\nexport interface AssetsConfig extends BaseConfig {\n\tnetworkType: NetworkType;\n\tselectedAddress: string;\n}\n\n/**\n * @type AssetSuggestionResult\n *\n * @property result - Promise resolving to a new suggested asset address\n * @property suggestedAssetMeta - Meta information about this new suggested asset\n */\nexport interface AssetSuggestionResult {\n\tresult: Promise<string>;\n\tsuggestedAssetMeta: SuggestedAssetMeta;\n}\n\n/**\n * @type SuggestedAssetMeta\n *\n * Suggested asset by EIP747 meta data\n *\n * @property error - Synthesized error information for failed asset suggestions\n * @property id - Generated UUID associated with this suggested asset\n * @property status - String status of this this suggested asset\n * @property time - Timestamp associated with this this suggested asset\n * @property type - Type type this suggested asset\n * @property asset - Asset suggested object\n */\nexport interface SuggestedAssetMeta {\n\terror?: {\n\t\tmessage: string;\n\t\tstack?: string;\n\t};\n\tid: string;\n\tstatus: string;\n\ttime: number;\n\ttype: string;\n\tasset: Token;\n}\n\n/**\n * @type AssetsState\n *\n * Assets controller state\n *\n * @property allTokens - Object containing tokens per account and network\n * @property allCollectibleContracts - Object containing collectibles contract information\n * @property allCollectibles - Object containing collectibles per account and network\n * @property collectibleContracts - List of collectibles contracts associated with the active vault\n * @property collectibles - List of collectibles associated with the active vault\n * @property suggestedAssets - List of suggested assets associated with the active vault\n * @property tokens - List of tokens associated with the active vault\n * @property ignoredTokens - List of tokens that should be ignored\n * @property ignoredCollectibles - List of collectibles that should be ignored\n */\nexport interface AssetsState extends BaseState {\n\tallTokens: { [key: string]: { [key: string]: Token[] } };\n\tallCollectibleContracts: { [key: string]: { [key: string]: CollectibleContract[] } };\n\tallCollectibles: { [key: string]: { [key: string]: Collectible[] } };\n\tcollectibleContracts: CollectibleContract[];\n\tcollectibles: Collectible[];\n\tignoredTokens: Token[];\n\tignoredCollectibles: Collectible[];\n\tsuggestedAssets: SuggestedAssetMeta[];\n\ttokens: Token[];\n}\n\n/**\n * Controller that stores assets and exposes convenience methods\n */\nexport class AssetsController extends BaseController<AssetsConfig, AssetsState> {\n\tprivate mutex = new Mutex();\n\n\tprivate getCollectibleApi(contractAddress: string, tokenId: number) {\n\t\treturn `https://api.opensea.io/api/v1/asset/${contractAddress}/${tokenId}`;\n\t}\n\n\tprivate getCollectibleContractInformationApi(contractAddress: string) {\n\t\treturn `https://api.opensea.io/api/v1/asset_contract/${contractAddress}`;\n\t}\n\n\tprivate failSuggestedAsset(suggestedAssetMeta: SuggestedAssetMeta, error: Error) {\n\t\tsuggestedAssetMeta.status = 'failed';\n\t\tsuggestedAssetMeta.error = {\n\t\t\tmessage: error.toString(),\n\t\t\tstack: error.stack\n\t\t};\n\t\tthis.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);\n\t}\n\n\t/**\n\t * Get collectible tokenURI API following ERC721\n\t *\n\t * @param contractAddress - ERC721 asset contract address\n\t * @param tokenId - ERC721 asset identifier\n\t * @returns - Collectible tokenURI\n\t */\n\tprivate async getCollectibleTokenURI(contractAddress: string, tokenId: number): Promise<string> {\n\t\tconst assetsContract = this.context.AssetsContractController as AssetsContractController;\n\t\tconst supportsMetadata = await assetsContract.contractSupportsMetadataInterface(contractAddress);\n\t\t/* istanbul ignore if */\n\t\tif (!supportsMetadata) {\n\t\t\treturn '';\n\t\t}\n\t\tconst tokenURI = await assetsContract.getCollectibleTokenURI(contractAddress, tokenId);\n\t\treturn tokenURI;\n\t}\n\n\t/**\n\t * Request individual collectible information from OpenSea api\n\t *\n\t * @param contractAddress - Hex address of the collectible contract\n\t * @param tokenId - The collectible identifier\n\t * @returns - Promise resolving to the current collectible name and image\n\t */\n\tprivate async getCollectibleInformationFromApi(\n\t\tcontractAddress: string,\n\t\ttokenId: number\n\t): Promise<CollectibleInformation> {\n\t\tconst tokenURI = this.getCollectibleApi(contractAddress, tokenId);\n\t\tlet collectibleInformation: ApiCollectibleResponse;\n\t\t/* istanbul ignore if */\n\t\tif (this.openSeaApiKey) {\n\t\t\tcollectibleInformation = await handleFetch(tokenURI, { headers: { 'X-API-KEY': this.openSeaApiKey } });\n\t\t} else {\n\t\t\tcollectibleInformation = await handleFetch(tokenURI);\n\t\t}\n\t\tconst { name, description, image_original_url } = collectibleInformation;\n\t\treturn { image: image_original_url, name, description };\n\t}\n\n\t/**\n\t * Request individual collectible information from contracts that follows Metadata Interface\n\t *\n\t * @param contractAddress - Hex address of the collectible contract\n\t * @param tokenId - The collectible identifier\n\t * @returns - Promise resolving to the current collectible name and image\n\t */\n\tprivate async getCollectibleInformationFromTokenURI(\n\t\tcontractAddress: string,\n\t\ttokenId: number\n\t): Promise<CollectibleInformation> {\n\t\tconst tokenURI = await this.getCollectibleTokenURI(contractAddress, tokenId);\n\t\tconst object = await handleFetch(tokenURI);\n\t\tconst image = object.hasOwnProperty('image') ? 'image' : /* istanbul ignore next */ 'image_url';\n\t\treturn { image: object[image], name: object.name };\n\t}\n\n\t/**\n\t * Request individual collectible information (name, image url and description)\n\t *\n\t * @param contractAddress - Hex address of the collectible contract\n\t * @param tokenId - The collectible identifier\n\t * @returns - Promise resolving to the current collectible name and image\n\t */\n\tprivate async getCollectibleInformation(contractAddress: string, tokenId: number): Promise<CollectibleInformation> {\n\t\tlet information;\n\t\t// First try with OpenSea\n\t\tinformation = await safelyExecute(async () => {\n\t\t\treturn await this.getCollectibleInformationFromApi(contractAddress, tokenId);\n\t\t});\n\t\tif (information) {\n\t\t\treturn information;\n\t\t}\n\t\t// Then following ERC721 standard\n\t\tinformation = await safelyExecute(async () => {\n\t\t\treturn await this.getCollectibleInformationFromTokenURI(contractAddress, tokenId);\n\t\t});\n\t\t/* istanbul ignore next */\n\t\tif (information) {\n\t\t\treturn information;\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn {};\n\t}\n\n\t/**\n\t * Request collectible contract information from OpenSea api\n\t *\n\t * @param contractAddress - Hex address of the collectible contract\n\t * @returns - Promise resolving to the current collectible name and image\n\t */\n\tprivate async getCollectibleContractInformationFromApi(\n\t\tcontractAddress: string\n\t): Promise<ApiCollectibleContractResponse> {\n\t\tconst api = this.getCollectibleContractInformationApi(contractAddress);\n\t\tlet collectibleContractObject;\n\t\t/* istanbul ignore if */\n\t\tif (this.openSeaApiKey) {\n\t\t\tcollectibleContractObject = await handleFetch(api, { headers: { 'X-API-KEY': this.openSeaApiKey } });\n\t\t} else {\n\t\t\tcollectibleContractObject = await handleFetch(api);\n\t\t}\n\t\tconst { name, symbol, image_url, description, total_supply } = collectibleContractObject;\n\t\treturn { name, symbol, image_url, description, total_supply };\n\t}\n\n\t/**\n\t * Request collectible contract information from the contract itself\n\t *\n\t * @param contractAddress - Hex address of the collectible contract\n\t * @returns - Promise resolving to the current collectible name and image\n\t */\n\tprivate async getCollectibleContractInformationFromContract(\n\t\tcontractAddress: string\n\t): Promise<ApiCollectibleContractResponse> {\n\t\tconst assetsContractController = this.context.AssetsContractController as AssetsContractController;\n\t\tconst name = await assetsContractController.getAssetName(contractAddress);\n\t\tconst symbol = await assetsContractController.getAssetSymbol(contractAddress);\n\t\treturn { name, symbol };\n\t}\n\n\t/**\n\t * Request collectible contract information from OpenSea api\n\t *\n\t * @param contractAddress - Hex address of the collectible contract\n\t * @returns - Promise resolving to the collectible contract name, image and description\n\t */\n\tprivate async getCollectibleContractInformation(contractAddress: string): Promise<ApiCollectibleContractResponse> {\n\t\tlet information;\n\t\t// First try with OpenSea\n\t\tinformation = await safelyExecute(async () => {\n\t\t\treturn await this.getCollectibleContractInformationFromApi(contractAddress);\n\t\t});\n\t\tif (information) {\n\t\t\treturn information;\n\t\t}\n\t\t// Then following ERC721 standard\n\t\tinformation = await safelyExecute(async () => {\n\t\t\treturn await this.getCollectibleContractInformationFromContract(contractAddress);\n\t\t});\n\t\tif (information) {\n\t\t\treturn information;\n\t\t}\n\t\t/* istanbul ignore next */\n\t\treturn {};\n\t}\n\n\t/**\n\t * Adds an individual collectible to the stored collectible list\n\t *\n\t * @param address - Hex address of the collectible contract\n\t * @param tokenId - The collectible identifier\n\t * @param opts - Collectible optional information (name, image and description)\n\t * @param detection? - Whether the collectible is manually added or autodetected\n\t * @returns - Promise resolving to the current collectible list\n\t */\n\tprivate async addIndividualCollectible(\n\t\taddress: string,\n\t\ttokenId: number,\n\t\topts?: CollectibleInformation\n\t): Promise<Collectible[]> {\n\t\tconst releaseLock = await this.mutex.acquire();\n\t\taddress = toChecksumAddress(address);\n\t\tconst { allCollectibles, collectibles } = this.state;\n\t\tconst { networkType, selectedAddress } = this.config;\n\t\tconst existingEntry = collectibles.find(\n\t\t\t(collectible) => collectible.address === address && collectible.tokenId === tokenId\n\t\t);\n\t\tif (existingEntry) {\n\t\t\treleaseLock();\n\t\t\treturn collectibles;\n\t\t}\n\t\tconst { name, image, description } = opts ? opts : await this.getCollectibleInformation(address, tokenId);\n\t\tconst newEntry: Collectible = { address, tokenId, name, image, description };\n\t\tconst newCollectibles = [...collectibles, newEntry];\n\t\tconst addressCollectibles = allCollectibles[selectedAddress];\n\t\tconst newAddressCollectibles = { ...addressCollectibles, ...{ [networkType]: newCollectibles } };\n\t\tconst newAllCollectibles = { ...allCollectibles, ...{ [selectedAddress]: newAddressCollectibles } };\n\t\tthis.update({ allCollectibles: newAllCollectibles, collectibles: newCollectibles });\n\t\treleaseLock();\n\t\treturn newCollectibles;\n\t}\n\n\t/**\n\t * Adds a collectible contract to the stored collectible contracts list\n\t *\n\t * @param address - Hex address of the collectible contract\n\t * @param detection? - Whether the collectible is manually added or auto-detected\n\t * @returns - Promise resolving to the current collectible contracts list\n\t */\n\tprivate async addCollectibleContract(address: string, detection?: boolean): Promise<CollectibleContract[]> {\n\t\tconst releaseLock = await this.mutex.acquire();\n\t\taddress = toChecksumAddress(address);\n\t\tconst { allCollectibleContracts, collectibleContracts } = this.state;\n\t\tconst { networkType, selectedAddress } = this.config;\n\t\tconst existingEntry = collectibleContracts.find(\n\t\t\t(collectibleContract) => collectibleContract.address === address\n\t\t);\n\t\tif (existingEntry) {\n\t\t\treleaseLock();\n\t\t\treturn collectibleContracts;\n\t\t}\n\t\tconst contractInformation = await this.getCollectibleContractInformation(address);\n\t\tconst { name, symbol, image_url, description, total_supply } = contractInformation;\n\t\t// If being auto-detected opensea information is expected\n\t\t// Oherwise at least name and symbol from contract is needed\n\t\tif ((detection && !image_url) || Object.keys(contractInformation).length === 0) {\n\t\t\treleaseLock();\n\t\t\treturn collectibleContracts;\n\t\t}\n\t\tconst newEntry: CollectibleContract = {\n\t\t\taddress,\n\t\t\tdescription,\n\t\t\tlogo: image_url,\n\t\t\tname,\n\t\t\tsymbol,\n\t\t\ttotalSupply: total_supply\n\t\t};\n\t\tconst newCollectibleContracts = [...collectibleContracts, newEntry];\n\t\tconst addressCollectibleContracts = allCollectibleContracts[selectedAddress];\n\t\tconst newAddressCollectibleContracts = {\n\t\t\t...addressCollectibleContracts,\n\t\t\t...{ [networkType]: newCollectibleContracts }\n\t\t};\n\t\tconst newAllCollectibleContracts = {\n\t\t\t...allCollectibleContracts,\n\t\t\t...{ [selectedAddress]: newAddressCollectibleContracts }\n\t\t};\n\t\tthis.update({\n\t\t\tallCollectibleContracts: newAllCollectibleContracts,\n\t\t\tcollectibleContracts: newCollectibleContracts\n\t\t});\n\t\treleaseLock();\n\t\treturn newCollectibleContracts;\n\t}\n\n\t/**\n\t * Removes an individual collectible from the stored token list and saves it in ignored collectibles list\n\t *\n\t * @param address - Hex address of the collectible contract\n\t * @param tokenId - Token identifier of the collectible\n\t */\n\tprivate removeAndIgnoreIndividualCollectible(address: string, tokenId: number) {\n\t\taddress = toChecksumAddress(address);\n\t\tconst { allCollectibles, collectibles, ignoredCollectibles } = this.state;\n\t\tconst { networkType, selectedAddress } = this.config;\n\t\tconst newIgnoredCollectibles = [...ignoredCollectibles];\n\t\tconst newCollectibles = collectibles.filter((collectible) => {\n\t\t\tif (collectible.address === address && collectible.tokenId === tokenId) {\n\t\t\t\tconst alreadyIgnored = newIgnoredCollectibles.find(\n\t\t\t\t\t(c) => c.address === address && c.tokenId === tokenId\n\t\t\t\t);\n\t\t\t\t!alreadyIgnored && newIgnoredCollectibles.push(collectible);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\tconst addressCollectibles = allCollectibles[selectedAddress];\n\t\tconst newAddressCollectibles = { ...addressCollectibles, ...{ [networkType]: newCollectibles } };\n\t\tconst newAllCollectibles = { ...allCollectibles, ...{ [selectedAddress]: newAddressCollectibles } };\n\t\tthis.update({\n\t\t\tallCollectibles: newAllCollectibles,\n\t\t\tcollectibles: newCollectibles,\n\t\t\tignoredCollectibles: newIgnoredCollectibles\n\t\t});\n\t}\n\n\t/**\n\t * Removes an individual collectible from the stored token list\n\t *\n\t * @param address - Hex address of the collectible contract\n\t * @param tokenId - Token identifier of the collectible\n\t */\n\tprivate removeIndividualCollectible(address: string, tokenId: number) {\n\t\taddress = toChecksumAddress(address);\n\t\tconst { allCollectibles, collectibles } = this.state;\n\t\tconst { networkType, selectedAddress } = this.config;\n\t\tconst newCollectibles = collectibles.filter(\n\t\t\t(collectible) => !(collectible.address === address && collectible.tokenId === tokenId)\n\t\t);\n\t\tconst addressCollectibles = allCollectibles[selectedAddress];\n\t\tconst newAddressCollectibles = { ...addressCollectibles, ...{ [networkType]: newCollectibles } };\n\t\tconst newAllCollectibles = { ...allCollectibles, ...{ [selectedAddress]: newAddressCollectibles } };\n\t\tthis.update({ allCollectibles: newAllCollectibles, collectibles: newCollectibles });\n\t}\n\n\t/**\n\t * Removes a collectible contract to the stored collectible contracts list\n\t *\n\t * @param address - Hex address of the collectible contract\n\t * @returns - Promise resolving to the current collectible contracts list\n\t */\n\tprivate removeCollectibleContract(address: string): CollectibleContract[] {\n\t\taddress = toChecksumAddress(address);\n\t\tconst { allCollectibleContracts, collectibleContracts } = this.state;\n\t\tconst { networkType, selectedAddress } = this.config;\n\t\tconst newCollectibleContracts = collectibleContracts.filter(\n\t\t\t(collectibleContract) => !(collectibleContract.address === address)\n\t\t);\n\t\tconst addressCollectibleContracts = allCollectibleContracts[selectedAddress];\n\t\tconst newAddressCollectibleContracts = {\n\t\t\t...addressCollectibleContracts,\n\t\t\t...{ [networkType]: newCollectibleContracts }\n\t\t};\n\t\tconst newAllCollectibleContracts = {\n\t\t\t...allCollectibleContracts,\n\t\t\t...{ [selectedAddress]: newAddressCollectibleContracts }\n\t\t};\n\t\tthis.update({\n\t\t\tallCollectibleContracts: newAllCollectibleContracts,\n\t\t\tcollectibleContracts: newCollectibleContracts\n\t\t});\n\t\treturn newCollectibleContracts;\n\t}\n\n\t/**\n\t * EventEmitter instance used to listen to specific EIP747 events\n\t */\n\thub = new EventEmitter();\n\n\t/**\n\t * Optional API key to use with opensea\n\t */\n\topenSeaApiKey?: string;\n\n\t/**\n\t * Name of this controller used during composition\n\t */\n\tname = 'AssetsController';\n\n\t/**\n\t * List of required sibling controllers this controller needs to function\n\t */\n\trequiredControllers = ['AssetsContractController', 'NetworkController', 'PreferencesController'];\n\n\t/**\n\t * Creates a AssetsController instance\n\t *\n\t * @param config - Initial options used to configure this controller\n\t * @param state - Initial state to set on this controller\n\t */\n\tconstructor(config?: Partial<BaseConfig>, state?: Partial<AssetsState>) {\n\t\tsuper(config, state);\n\t\tthis.defaultConfig = {\n\t\t\tnetworkType: 'mainnet',\n\t\t\tselectedAddress: ''\n\t\t};\n\t\tthis.defaultState = {\n\t\t\tallCollectibleContracts: {},\n\t\t\tallCollectibles: {},\n\t\t\tallTokens: {},\n\t\t\tcollectibleContracts: [],\n\t\t\tcollectibles: [],\n\t\t\tignoredCollectibles: [],\n\t\t\tignoredTokens: [],\n\t\t\tsuggestedAssets: [],\n\t\t\ttokens: []\n\t\t};\n\t\tthis.initialize();\n\t}\n\n\t/**\n\t * Sets an OpenSea API key to retrieve collectible information\n\t *\n\t * @param openSeaApiKey - OpenSea API key\n\t */\n\tsetApiKey(openSeaApiKey: string) {\n\t\tthis.openSeaApiKey = openSeaApiKey;\n\t}\n\n\t/**\n\t * Adds a token to the stored token list\n\t *\n\t * @param address - Hex address of the token contract\n\t * @param symbol - Symbol of the token\n\t * @param decimals - Number of decimals the token uses\n\t * @param image - Image of the token\n\t * @returns - Current token list\n\t */\n\tasync addToken(address: string, symbol: string, decimals: number, image?: string): Promise<Token[]> {\n\t\tconst releaseLock = await this.mutex.acquire();\n\t\taddress = toChecksumAddress(address);\n\t\tconst { allTokens, tokens } = this.state;\n\t\tconst { networkType, selectedAddress } = this.config;\n\t\tconst newEntry: Token = { address, symbol, decimals, image };\n\t\tconst previousEntry = tokens.find((token) => token.address === address);\n\t\tif (previousEntry) {\n\t\t\tconst previousIndex = tokens.indexOf(previousEntry);\n\t\t\ttokens[previousIndex] = newEntry;\n\t\t} else {\n\t\t\ttokens.push(newEntry);\n\t\t}\n\t\tconst addressTokens = allTokens[selectedAddress];\n\t\tconst newAddressTokens = { ...addressTokens, ...{ [networkType]: tokens } };\n\t\tconst newAllTokens = { ...allTokens, ...{ [selectedAddress]: newAddressTokens } };\n\t\tconst newTokens = [...tokens];\n\t\tthis.update({ allTokens: newAllTokens, tokens: newTokens });\n\t\treleaseLock();\n\t\treturn newTokens;\n\t}\n\n\t/**\n\t * Adds a new suggestedAsset to state. Parameters will be validated according to\n\t * asset type being watched. A `<suggestedAssetMeta.id>:pending` hub event will be emitted once added.\n\t *\n\t * @param asset - Asset to be watched. For now only ERC20 tokens are accepted.\n\t * @param type - Asset type\n\t * @returns - Object containing a promise resolving to the suggestedAsset address if accepted\n\t */\n\tasync watchAsset(asset: Token, type: string): Promise<AssetSuggestionResult> {\n\t\tconst suggestedAssetMeta: SuggestedAssetMeta = {\n\t\t\tasset,\n\t\t\tid: random(),\n\t\t\tstatus: 'pending',\n\t\t\ttime: Date.now(),\n\t\t\ttype\n\t\t};\n\t\ttry {\n\t\t\tswitch (type) {\n\t\t\t\tcase 'ERC20':\n\t\t\t\t\tvalidateTokenToWatch(asset);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Asset of type ${type} not supported`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.failSuggestedAsset(suggestedAssetMeta, error);\n\t\t\treturn Promise.reject(error);\n\t\t}\n\n\t\tconst result: Promise<string> = new Promise((resolve, reject) => {\n\t\t\tthis.hub.once(`${suggestedAssetMeta.id}:finished`, (meta: SuggestedAssetMeta) => {\n\t\t\t\tswitch (meta.status) {\n\t\t\t\t\tcase 'accepted':\n\t\t\t\t\t\treturn resolve(meta.asset.address);\n\t\t\t\t\tcase 'rejected':\n\t\t\t\t\t\treturn reject(new Error('User rejected to watch the asset.'));\n\t\t\t\t\tcase 'failed':\n\t\t\t\t\t\treturn reject(new Error(meta.error!.message));\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tconst { suggestedAssets } = this.state;\n\t\tsuggestedAssets.push(suggestedAssetMeta);\n\t\tthis.update({ suggestedAssets: [...suggestedAssets] });\n\t\tthis.hub.emit('pendingSuggestedAsset', suggestedAssetMeta);\n\t\treturn { result, suggestedAssetMeta };\n\t}\n\n\t/**\n\t * Accepts to watch an asset and updates it's status and deletes the suggestedAsset from state,\n\t * adding the asset to corresponding asset state. In this case ERC20 tokens.\n\t * A `<suggestedAssetMeta.id>:finished` hub event is fired after accepted or failure.\n\t *\n\t * @param suggestedAssetID - ID of the suggestedAsset to accept\n\t * @returns - Promise resolving when this operation completes\n\t */\n\tasync acceptWatchAsset(suggestedAssetID: string): Promise<void> {\n\t\tconst { suggestedAssets } = this.state;\n\t\tconst index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);\n\t\tconst suggestedAssetMeta = suggestedAssets[index];\n\t\ttry {\n\t\t\tswitch (suggestedAssetMeta.type) {\n\t\t\t\tcase 'ERC20':\n\t\t\t\t\tconst { address, symbol, decimals, image } = suggestedAssetMeta.asset;\n\t\t\t\t\tawait this.addToken(address, symbol, decimals, image);\n\t\t\t\t\tsuggestedAssetMeta.status = 'accepted';\n\t\t\t\t\tthis.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new Error(`Asset of type ${suggestedAssetMeta.type} not supported`);\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.failSuggestedAsset(suggestedAssetMeta, error);\n\t\t}\n\t\tconst newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);\n\t\tthis.update({ suggestedAssets: [...newSuggestedAssets] });\n\t}\n\n\t/**\n\t * Rejects a watchAsset request based on its ID by setting its status to \"rejected\"\n\t * and emitting a `<suggestedAssetMeta.id>:finished` hub event.\n\t *\n\t * @param suggestedAssetID - ID of the suggestedAsset to accept\n\t */\n\trejectWatchAsset(suggestedAssetID: string) {\n\t\tconst { suggestedAssets } = this.state;\n\t\tconst index = suggestedAssets.findIndex(({ id }) => suggestedAssetID === id);\n\t\tconst suggestedAssetMeta = suggestedAssets[index];\n\t\tif (!suggestedAssetMeta) {\n\t\t\treturn;\n\t\t}\n\t\tsuggestedAssetMeta.status = 'rejected';\n\t\tthis.hub.emit(`${suggestedAssetMeta.id}:finished`, suggestedAssetMeta);\n\t\tconst newSuggestedAssets = suggestedAssets.filter(({ id }) => id !== suggestedAssetID);\n\t\tthis.update({ suggestedAssets: [...newSuggestedAssets] });\n\t}\n\n\t/**\n\t * Adds a collectible and respective collectible contract to the stored collectible and collectible contracts lists\n\t *\n\t * @param address - Hex address of the collectible contract\n\t * @param tokenId - The collectible identifier\n\t * @param opts - Collectible optional information (name, image and description)\n\t * @param detection? - Whether the collectible is manually added or autodetected\n\t * @returns - Promise resolving to the current collectible list\n\t */\n\tasync addCollectible(address: string, tokenId: number, opts?: CollectibleInformation, detection?: boolean) {\n\t\taddress = toChecksumAddress(address);\n\t\tconst newCollectibleContracts = await this.addCollectibleContract(address, detection);\n\t\t// If collectible contract was not added, do not add individual collectible\n\t\tconst collectibleContract = newCollectibleContracts.find((contract) => contract.address === address);\n\t\t// If collectible contract information, add individual collectible\n\t\tif (collectibleContract) {\n\t\t\tawait this.addIndividualCollectible(address, tokenId, opts);\n\t\t}\n\t}\n\n\t/**\n\t * Removes a token from the stored token list and saves it in ignored tokens list\n\t *\n\t * @param address - Hex address of the token contract\n\t */\n\tremoveAndIgnoreToken(address: string) {\n\t\taddress = toChecksumAddress(address);\n\t\tconst { allTokens, tokens, ignoredTokens } = this.state;\n\t\tconst { networkType, selectedAddress } = this.config;\n\t\tconst newIgnoredTokens = [...ignoredTokens];\n\t\tconst newTokens = tokens.filter((token) => {\n\t\t\tif (token.address === address) {\n\t\t\t\tconst alreadyIgnored = newIgnoredTokens.find((t) => t.address === address);\n\t\t\t\t!alreadyIgnored && newIgnoredTokens.push(token);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\treturn true;\n\t\t});\n\t\tconst addressTokens = allTokens[selectedAddress];\n\t\tconst newAddressTokens = { ...addressTokens, ...{ [networkType]: newTokens } };\n\t\tconst newAllTokens = { ...allTokens, ...{ [selectedAddress]: newAddressTokens } };\n\t\tthis.update({ allTokens: newAllTokens, tokens: newTokens, ignoredTokens: newIgnoredTokens });\n\t}\n\n\t/**\n\t * Removes a token from the stored token list\n\t *\n\t * @param address - Hex address of the token contract\n\t */\n\tremoveToken(address: string) {\n\t\taddress = toChecksumAddress(address);\n\t\tconst { allTokens, tokens } = this.state;\n\t\tconst { networkType, selectedAddress } = this.config;\n\t\tconst newTokens = tokens.filter((token) => token.address !== address);\n\t\tconst addressTokens = allTokens[selectedAddress];\n\t\tconst newAddressTokens = { ...addressTokens, ...{ [networkType]: newTokens } };\n\t\tconst newAllTokens = { ...allTokens, ...{ [selectedAddress]: newAddressTokens } };\n\t\tthis.update({ allTokens: newAllTokens, tokens: newTokens });\n\t}\n\n\t/**\n\t * Removes a collectible from the stored token list\n\t *\n\t * @param address - Hex address of the collectible contract\n\t * @param tokenId - Token identifier of the collectible\n\t */\n\tremoveCollectible(address: string, tokenId: number) {\n\t\taddress = toChecksumAddress(address);\n\t\tthis.removeIndividualCollectible(address, tokenId);\n\t\tconst { collectibles } = this.state;\n\t\tconst remainingCollectible = collectibles.find((collectible) => collectible.address === address);\n\t\tif (!remainingCollectible) {\n\t\t\tthis.removeCollectibleContract(address);\n\t\t}\n\t}\n\n\t/**\n\t * Removes a collectible from the stored token list and saves it in ignored collectibles list\n\t *\n\t * @param address - Hex address of the collectible contract\n\t * @param tokenId - Token identifier of the collectible\n\t */\n\tremoveAndIgnoreCollectible(address: string, tokenId: number) {\n\t\taddress = toChecksumAddress(address);\n\t\tthis.removeAndIgnoreIndividualCollectible(address, tokenId);\n\t\tconst { collectibles } = this.state;\n\t\tconst remainingCollectible = collectibles.find((collectible) => collectible.address === address);\n\t\tif (!remainingCollectible) {\n\t\t\tthis.removeCollectibleContract(address);\n\t\t}\n\t}\n\n\t/**\n\t * Removes all tokens from the ignored list\n\t */\n\tclearIgnoredTokens() {\n\t\tthis.update({ ignoredTokens: [] });\n\t}\n\n\t/**\n\t * Removes all collectibles from the ignored list\n\t */\n\tclearIgnoredCollectibles() {\n\t\tthis.update({ ignoredCollectibles: [] });\n\t}\n\n\t/**\n\t * Extension point called if and when this controller is composed\n\t * with other controllers using a ComposableController\n\t */\n\tonComposed() {\n\t\tsuper.onComposed();\n\t\tconst preferences = this.context.PreferencesController as PreferencesController;\n\t\tconst network = this.context.NetworkController as NetworkController;\n\t\tpreferences.subscribe(({ selectedAddress }) => {\n\t\t\tconst { allCollectibleContracts, allCollectibles, allTokens } = this.state;\n\t\t\tconst { networkType } = this.config;\n\t\t\tthis.configure({ selectedAddress });\n\t\t\tthis.update({\n\t\t\t\tcollectibleContracts:\n\t\t\t\t\t(allCollectibleContracts[selectedAddress] &&\n\t\t\t\t\t\tallCollectibleContracts[selectedAddress][networkType]) ||\n\t\t\t\t\t[],\n\t\t\t\tcollectibles: (allCollectibles[selectedAddress] && allCollectibles[selectedAddress][networkType]) || [],\n\t\t\t\ttokens: (allTokens[selectedAddress] && allTokens[selectedAddress][networkType]) || []\n\t\t\t});\n\t\t});\n\t\tnetwork.subscribe(({ provider }) => {\n\t\t\tconst { allCollectibleContracts, allCollectibles, allTokens } = this.state;\n\t\t\tconst { selectedAddress } = this.config;\n\t\t\tconst networkType = provider.type;\n\t\t\tthis.configure({ networkType });\n\t\t\tthis.update({\n\t\t\t\tcollectibleContracts:\n\t\t\t\t\t(allCollectibleContracts[selectedAddress] &&\n\t\t\t\t\t\tallCollectibleContracts[selectedAddress][networkType]) ||\n\t\t\t\t\t[],\n\t\t\t\tcollectibles: (allCollectibles[selectedAddress] && allCollectibles[selectedAddress][networkType]) || [],\n\t\t\t\ttokens: (allTokens[selectedAddress] && allTokens[selectedAddress][networkType]) || []\n\t\t\t});\n\t\t});\n\t}\n}\n\nexport default AssetsController;\n"]}