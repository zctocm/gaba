{"version":3,"file":"KeyringController.js","sourceRoot":"","sources":["../../src/keyring/KeyringController.ts"],"names":[],"mappings":"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","sourcesContent":["import { toChecksumAddress } from 'ethereumjs-util';\nimport BaseController, { BaseConfig, BaseState, Listener } from '../BaseController';\nimport PreferencesController from '../user/PreferencesController';\nimport { Transaction } from '../transaction/TransactionController';\nimport { PersonalMessageParams } from '../message-manager/PersonalMessageManager';\nimport { TypedMessageParams } from '../message-manager/TypedMessageManager';\nconst sigUtil = require('eth-sig-util');\nconst Keyring = require('eth-keyring-controller');\nconst Mutex = require('await-semaphore').Mutex;\nconst Wallet = require('ethereumjs-wallet');\nconst ethUtil = require('ethereumjs-util');\nconst importers = require('ethereumjs-wallet/thirdparty');\nconst privates = new WeakMap();\n/**\n * Available keyring types\n */\nexport enum KeyringTypes {\n\tsimple = 'Simple Key Pair',\n\thd = 'HD Key Tree'\n}\n\n/**\n * @type KeyringObject\n *\n * Keyring object\n *\n * @property type - Keyring type\n * @property accounts - Associated accounts\n * @function getAccounts - Get associated accounts\n */\nexport interface KeyringObject {\n\ttype: string;\n\taccounts: string[];\n\tgetAccounts(): string[];\n}\n\n/**\n * @type KeyringState\n *\n * Keyring controller state\n *\n * @property vault - Encrypted string representing keyring data\n * @property keyrings - Group of accounts\n */\nexport interface KeyringState extends BaseState {\n\tvault?: string;\n\tkeyrings: Keyring[];\n}\n\n/**\n * @type KeyringMemState\n *\n * Keyring mem controller state\n *\n * @property isUnlocked - Whether vault is unlocked\n * @property keyringTypes - Account types\n * @property keyrings - Group of accounts\n */\nexport interface KeyringMemState extends BaseState {\n\tisUnlocked: boolean;\n\tkeyringTypes: string[];\n\tkeyrings: Keyring[];\n}\n\n/**\n * @type KeyringConfig\n *\n * Keyring controller configuration\n *\n * @property encryptor - Keyring encryptor\n */\nexport interface KeyringConfig extends BaseConfig {\n\tencryptor?: any;\n}\n\n/**\n * @type Keyring\n *\n * Keyring object to return in fullUpdate\n *\n * @property type - Keyring type\n * @property accounts - Associated accounts\n * @property index - Associated index\n */\nexport interface Keyring {\n\taccounts: string[];\n\ttype: string;\n\tindex?: number;\n}\n\n/**\n * Controller responsible for establishing and managing user identity\n */\nexport class KeyringController extends BaseController<KeyringConfig, KeyringState> {\n\tprivate mutex = new Mutex();\n\n\t/**\n\t * Name of this controller used during composition\n\t */\n\tname = 'KeyringController';\n\n\t/**\n\t * List of required sibling controllers this controller needs to function\n\t */\n\trequiredControllers = ['PreferencesController'];\n\n\t/**\n\t * Creates a KeyringController instance\n\t *\n\t * @param config - Initial options used to configure this controller\n\t * @param state - Initial state to set on this controller\n\t */\n\tconstructor(config?: Partial<KeyringConfig>, state?: Partial<KeyringState>) {\n\t\tsuper(config, state);\n\t\tprivates.set(this, { keyring: new Keyring(Object.assign({ initState: state }, config)) });\n\t\tthis.defaultState = {\n\t\t\t...privates.get(this).keyring.store.getState(),\n\t\t\tkeyrings: []\n\t\t};\n\t\tthis.initialize();\n\t\tthis.fullUpdate();\n\t}\n\n\t/**\n\t * Adds a new account to the default (first) HD seed phrase keyring\n\t *\n\t * @returns - Promise resolving to current state when the account is added\n\t */\n\tasync addNewAccount(): Promise<KeyringMemState> {\n\t\tconst preferences = this.context.PreferencesController as PreferencesController;\n\t\tconst primaryKeyring = privates.get(this).keyring.getKeyringsByType('HD Key Tree')[0];\n\t\t/* istanbul ignore if */\n\t\tif (!primaryKeyring) {\n\t\t\tthrow new Error('No HD keyring found');\n\t\t}\n\t\tconst oldAccounts = await privates.get(this).keyring.getAccounts();\n\t\tawait privates.get(this).keyring.addNewAccount(primaryKeyring);\n\t\tconst newAccounts = await privates.get(this).keyring.getAccounts();\n\n\t\tawait this.verifySeedPhrase();\n\n\t\tpreferences.updateIdentities(newAccounts);\n\t\tnewAccounts.forEach((selectedAddress: string) => {\n\t\t\tif (!oldAccounts.includes(selectedAddress)) {\n\t\t\t\tpreferences.update({ selectedAddress });\n\t\t\t}\n\t\t});\n\t\treturn this.fullUpdate();\n\t}\n\n\t/**\n\t * Effectively the same as creating a new keychain then populating it\n\t * using the given seed phrase\n\t *\n\t * @param password - Password to unlock keychain\n\t * @param seed - Seed phrase to restore keychain\n\t * @returns - Promise resolving to th restored keychain object\n\t */\n\tasync createNewVaultAndRestore(password: string, seed: string) {\n\t\tconst preferences = this.context.PreferencesController as PreferencesController;\n\t\tconst releaseLock = await this.mutex.acquire();\n\t\ttry {\n\t\t\tpreferences.updateIdentities([]);\n\t\t\tconst vault = await privates.get(this).keyring.createNewVaultAndRestore(password, seed);\n\t\t\tpreferences.updateIdentities(await privates.get(this).keyring.getAccounts());\n\t\t\tpreferences.update({ selectedAddress: Object.keys(preferences.state.identities)[0] });\n\t\t\tthis.fullUpdate();\n\t\t\treleaseLock();\n\t\t\treturn vault;\n\t\t} catch (err) /* istanbul ignore next */ {\n\t\t\treleaseLock();\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Create a new primary keychain and wipe any previous keychains\n\t *\n\t * @param password - Password to unlock the new vault\n\t * @returns - Newly-created keychain object\n\t */\n\tasync createNewVaultAndKeychain(password: string) {\n\t\tconst preferences = this.context.PreferencesController as PreferencesController;\n\t\tconst releaseLock = await this.mutex.acquire();\n\t\ttry {\n\t\t\tconst vault = await privates.get(this).keyring.createNewVaultAndKeychain(password);\n\t\t\tpreferences.updateIdentities(await privates.get(this).keyring.getAccounts());\n\t\t\tpreferences.update({ selectedAddress: Object.keys(preferences.state.identities)[0] });\n\t\t\tthis.fullUpdate();\n\t\t\treleaseLock();\n\t\t\treturn vault;\n\t\t} catch (err) /* istanbul ignore next */ {\n\t\t\treleaseLock();\n\t\t\tthrow err;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the status of the vault\n\t *\n\t * @returns - Boolean returning true if the vault is unlocked\n\t */\n\tisUnlocked(): boolean {\n\t\treturn privates.get(this).keyring.memStore.getState().isUnlocked;\n\t}\n\n\t/**\n\t * Gets the seed phrase of the HD keyring\n\t *\n\t * @param password - Password of the keyring\n\t * @returns - Promise resolving to the seed phrase\n\t */\n\texportSeedPhrase(password: string) {\n\t\tif (privates.get(this).keyring.password === password) {\n\t\t\treturn privates.get(this).keyring.keyrings[0].mnemonic;\n\t\t}\n\t\tthrow new Error('Invalid password');\n\t}\n\n\t/**\n\t * Gets the private key from the keyring controlling an address\n\t *\n\t * @param password - Password of the keyring\n\t * @param address - Address to export\n\t * @returns - Promise resolving to the private key for an address\n\t */\n\texportAccount(password: string, address: string): Promise<string> {\n\t\tif (privates.get(this).keyring.password === password) {\n\t\t\treturn privates.get(this).keyring.exportAccount(address);\n\t\t}\n\t\tthrow new Error('Invalid password');\n\t}\n\n\t/**\n\t * Returns the public addresses of all accounts for the current keyring\n\t *\n\t * @returns - A promise resolving to an array of addresses\n\t */\n\tgetAccounts(): Promise<string[]> {\n\t\treturn privates.get(this).keyring.getAccounts();\n\t}\n\n\t/**\n\t * Imports an account with the specified import strategy\n\t *\n\t * @param strategy - Import strategy name\n\t * @param args - Array of arguments to pass to the underlying stategy\n\t * @returns - Promise resolving to current state when the import is complete\n\t */\n\tasync importAccountWithStrategy(strategy: string, args: any[]): Promise<KeyringMemState> {\n\t\tlet privateKey;\n\t\tconst preferences = this.context.PreferencesController as PreferencesController;\n\t\tswitch (strategy) {\n\t\t\tcase 'privateKey':\n\t\t\t\tconst [importedKey] = args;\n\t\t\t\tif (!importedKey) {\n\t\t\t\t\tthrow new Error('Cannot import an empty key.');\n\t\t\t\t}\n\t\t\t\tconst prefixed = ethUtil.addHexPrefix(importedKey);\n\t\t\t\tif (!ethUtil.isValidPrivate(ethUtil.toBuffer(prefixed))) {\n\t\t\t\t\tthrow new Error('Cannot import invalid private key.');\n\t\t\t\t}\n\t\t\t\tprivateKey = ethUtil.stripHexPrefix(prefixed);\n\t\t\t\tbreak;\n\t\t\tcase 'json':\n\t\t\t\tlet wallet;\n\t\t\t\tconst [input, password] = args;\n\t\t\t\ttry {\n\t\t\t\t\twallet = importers.fromEtherWallet(input, password);\n\t\t\t\t} catch (e) {\n\t\t\t\t\twallet = wallet || Wallet.fromV3(input, password, true);\n\t\t\t\t}\n\t\t\t\tprivateKey = ethUtil.bufferToHex(wallet.getPrivateKey());\n\t\t\t\tbreak;\n\t\t}\n\t\tconst newKeyring = await privates.get(this).keyring.addNewKeyring(KeyringTypes.simple, [privateKey]);\n\t\tconst accounts = await newKeyring.getAccounts();\n\t\tconst allAccounts = await privates.get(this).keyring.getAccounts();\n\t\tpreferences.updateIdentities(allAccounts);\n\t\tpreferences.update({ selectedAddress: accounts[0] });\n\t\treturn this.fullUpdate();\n\t}\n\n\t/**\n\t * Removes an account from keyring state\n\t *\n\t * @param address - Address of the account to remove\n\t * @returns - Promise resolving current state when this account removal completes\n\t */\n\tasync removeAccount(address: string): Promise<KeyringMemState> {\n\t\tconst preferences = this.context.PreferencesController as PreferencesController;\n\t\tpreferences.removeIdentity(address);\n\t\tawait privates.get(this).keyring.removeAccount(address);\n\t\treturn this.fullUpdate();\n\t}\n\n\t/**\n\t * Deallocates all secrets and locks the wallet\n\t *\n\t * @returns - Promise resolving to current state\n\t */\n\tsetLocked(): Promise<KeyringMemState> {\n\t\treturn privates.get(this).keyring.setLocked();\n\t}\n\n\t/**\n\t * Signs message by calling down into a specific keyring\n\t *\n\t * @param messageParams - PersonalMessageParams object to sign\n\t * @returns - Promise resolving to a signed message string\n\t */\n\tsignMessage(messageParams: PersonalMessageParams) {\n\t\treturn privates.get(this).keyring.signMessage(messageParams);\n\t}\n\n\t/**\n\t * Signs personal message by calling down into a specific keyring\n\t *\n\t * @param messageParams - PersonalMessageParams object to sign\n\t * @returns - Promise resolving to a signed message string\n\t */\n\tsignPersonalMessage(messageParams: PersonalMessageParams) {\n\t\treturn privates.get(this).keyring.signPersonalMessage(messageParams);\n\t}\n\n\t/**\n\t * Signs typed message by calling down into a specific keyring\n\t *\n\t * @param messageParams - TypedMessageParams object to sign\n\t * @param version - Compatibility version EIP712\n\t * @returns - Promise resolving to a signed message string or an error if any\n\t */\n\tasync signTypedMessage(messageParams: TypedMessageParams, version: string) {\n\t\ttry {\n\t\t\tconst address = sigUtil.normalize(messageParams.from);\n\t\t\tconst password = privates.get(this).keyring.password;\n\t\t\tconst privateKey = await this.exportAccount(password, address);\n\t\t\tconst privateKeyBuffer = ethUtil.toBuffer(ethUtil.addHexPrefix(privateKey));\n\t\t\tswitch (version) {\n\t\t\t\tcase 'V1':\n\t\t\t\t\treturn sigUtil.signTypedDataLegacy(privateKeyBuffer, { data: messageParams.data });\n\t\t\t\tcase 'V3':\n\t\t\t\t\treturn sigUtil.signTypedData(privateKeyBuffer, { data: JSON.parse(messageParams.data as string) });\n\t\t\t\tcase 'V4':\n\t\t\t\t\treturn sigUtil.signTypedData_v4(privateKeyBuffer, {\n\t\t\t\t\t\tdata: JSON.parse(messageParams.data as string)\n\t\t\t\t\t});\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthrow new Error('Keyring Controller signTypedMessage: ' + error);\n\t\t}\n\t}\n\n\t/**\n\t * Signs a transaction by calling down into a specific keyring\n\t *\n\t * @param transaction - Transaction object to sign\n\t * @param from - Address to sign from, should be in keychain\n\t * @returns - Promise resolving to a signed transaction string\n\t */\n\tsignTransaction(transaction: Transaction, from: string) {\n\t\treturn privates.get(this).keyring.signTransaction(transaction, from);\n\t}\n\n\t/**\n\t * Attempts to decrypt the current vault and load its keyrings\n\t *\n\t * @param password - Password to unlock the keychain\n\t * @returns - Promise resolving to the current state\n\t */\n\tasync submitPassword(password: string): Promise<KeyringMemState> {\n\t\tconst preferences = this.context.PreferencesController as PreferencesController;\n\t\tawait privates.get(this).keyring.submitPassword(password);\n\t\tconst accounts = await privates.get(this).keyring.getAccounts();\n\t\tawait preferences.syncIdentities(accounts);\n\t\treturn this.fullUpdate();\n\t}\n\n\t/**\n\t * Adds new listener to be notified of state changes\n\t *\n\t * @param listener - Callback triggered when state changes\n\t */\n\tsubscribe(listener: Listener<KeyringState>) {\n\t\tprivates.get(this).keyring.store.subscribe(listener);\n\t}\n\n\t/**\n\t * Removes existing listener from receiving state changes\n\t *\n\t * @param listener - Callback to remove\n\t * @returns - True if a listener is found and unsubscribed\n\t */\n\tunsubscribe(listener: Listener<KeyringState>) {\n\t\treturn privates.get(this).keyring.store.unsubscribe(listener);\n\t}\n\n\t/**\n\t * Verifies the that the seed phrase restores the current keychain's accounts\n\t *\n\t * @returns - Promise resolving if the verification succeeds\n\t */\n\tasync verifySeedPhrase(): Promise<string> {\n\t\tconst primaryKeyring = privates.get(this).keyring.getKeyringsByType(KeyringTypes.hd)[0];\n\t\t/* istanbul ignore if */\n\t\tif (!primaryKeyring) {\n\t\t\tthrow new Error('No HD keyring found.');\n\t\t}\n\n\t\tconst seedWords = (await primaryKeyring.serialize()).mnemonic;\n\t\tconst accounts = await primaryKeyring.getAccounts();\n\t\t/* istanbul ignore if */\n\t\tif (accounts.length === 0) {\n\t\t\tthrow new Error('Cannot verify an empty keyring.');\n\t\t}\n\n\t\tconst TestKeyringClass = privates.get(this).keyring.getKeyringClassForType(KeyringTypes.hd);\n\t\tconst testKeyring = new TestKeyringClass({ mnemonic: seedWords, numberOfAccounts: accounts.length });\n\t\tconst testAccounts = await testKeyring.getAccounts();\n\t\t/* istanbul ignore if */\n\t\tif (testAccounts.length !== accounts.length) {\n\t\t\tthrow new Error('Seed phrase imported incorrect number of accounts.');\n\t\t}\n\n\t\ttestAccounts.forEach((account: string, i: number) => {\n\t\t\t/* istanbul ignore if */\n\t\t\tif (account.toLowerCase() !== accounts[i].toLowerCase()) {\n\t\t\t\tthrow new Error('Seed phrase imported different accounts.');\n\t\t\t}\n\t\t});\n\n\t\treturn seedWords;\n\t}\n\n\t/**\n\t * Update keyrings in state and calls KeyringController fullUpdate method returning current state\n\t *\n\t * @returns - Promise resolving to current state\n\t */\n\tasync fullUpdate(): Promise<KeyringMemState> {\n\t\tconst keyrings: Keyring[] = await Promise.all<Keyring>(\n\t\t\tprivates.get(this).keyring.keyrings.map(\n\t\t\t\tasync (keyring: KeyringObject, index: number): Promise<Keyring> => {\n\t\t\t\t\tconst keyringAccounts = await keyring.getAccounts();\n\t\t\t\t\tconst accounts = Array.isArray(keyringAccounts)\n\t\t\t\t\t\t? keyringAccounts.map((address) => toChecksumAddress(address))\n\t\t\t\t\t\t: /* istanbul ignore next */ [];\n\t\t\t\t\treturn {\n\t\t\t\t\t\taccounts,\n\t\t\t\t\t\tindex,\n\t\t\t\t\t\ttype: keyring.type\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t)\n\t\t);\n\t\tthis.update({ keyrings: [...keyrings] });\n\t\treturn privates.get(this).keyring.fullUpdate();\n\t}\n}\n\nexport default KeyringController;\n"]}