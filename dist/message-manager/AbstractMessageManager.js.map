{"version":3,"file":"AbstractMessageManager.js","sourceRoot":"","sources":["../../src/message-manager/AbstractMessageManager.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport BaseController, { BaseConfig, BaseState } from '../BaseController';\n\n/**\n * @type OriginalRequest\n *\n * Represents the original request object for adding a message.\n *\n * @property origin? - Is it is specified, represents the origin\n */\nexport interface OriginalRequest {\n\torigin?: string;\n}\n\n/**\n * @type Message\n *\n * Represents and contains data about a signing type signature request.\n *\n * @property id - An id to track and identify the message object\n * @property type - The json-prc signing method for which a signature request has been made.\n * A 'Message' which always has a signing type\n * @property rawSig - Raw data of the signature request\n */\nexport interface AbstractMessage {\n\tid: string;\n\ttime: number;\n\tstatus: string;\n\ttype: string;\n\trawSig?: string;\n}\n\n/**\n * @type MessageParams\n *\n * Represents the parameters to pass to the signing method once the signature request is approved.\n *\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface AbstractMessageParams {\n\tfrom: string;\n\torigin?: string;\n}\n\n/**\n * @type MessageParamsMetamask\n *\n * Represents the parameters to pass to the signing method once the signature request is approved\n * plus data added by MetaMask.\n *\n * @property metamaskId - Added for tracking and identification within MetaMask\n * @property from - Address to sign this message from\n * @property origin? - Added for request origin identification\n */\nexport interface AbstractMessageParamsMetamask extends AbstractMessageParams {\n\tmetamaskId: string;\n}\n\n/**\n * @type MessageManagerState\n *\n * Message Manager state\n *\n * @property unapprovedMessages - A collection of all Messages in the 'unapproved' state\n * @property unapprovedMessagesCount - The count of all Messages in this.unapprovedMessages\n */\nexport interface MessageManagerState<M extends AbstractMessage> extends BaseState {\n\tunapprovedMessages: { [key: string]: M };\n\tunapprovedMessagesCount: number;\n}\n\n/**\n * Controller in charge of managing - storing, adding, removing, updating - Messages.\n */\nexport abstract class AbstractMessageManager<\n\tM extends AbstractMessage,\n\tP extends AbstractMessageParams,\n\tPM extends AbstractMessageParamsMetamask\n> extends BaseController<BaseConfig, MessageManagerState<M>> {\n\tprotected messages: M[];\n\n\t/**\n\t * Saves the unapproved messages, and their count to state\n\t *\n\t */\n\tprotected saveMessageList() {\n\t\tconst unapprovedMessages = this.getUnapprovedMessages();\n\t\tconst unapprovedMessagesCount = this.getUnapprovedMessagesCount();\n\t\tthis.update({ unapprovedMessages, unapprovedMessagesCount });\n\t\tthis.hub.emit('updateBadge');\n\t}\n\n\t/**\n\t * Updates the status of a Message in this.messages\n\t *\n\t * @param messageId - The id of the Message to update\n\t * @param status - The new status of the Message\n\t */\n\tprotected setMessageStatus(messageId: string, status: string) {\n\t\tconst message = this.getMessage(messageId);\n\t\t/* istanbul ignore if */\n\t\tif (!message) {\n\t\t\tthrow new Error(`${this.context[name]}- Message not found for id: ${messageId}.`);\n\t\t}\n\t\tmessage.status = status;\n\t\tthis.updateMessage(message);\n\t\tthis.hub.emit(`${messageId}:${status}`, message);\n\t\tif (status === 'rejected' || status === 'signed' || status === 'errored') {\n\t\t\tthis.hub.emit(`${messageId}:finished`, message);\n\t\t}\n\t}\n\n\t/**\n\t * Sets a Message in this.messages to the passed Message if the ids are equal.\n\t * Then saves the unapprovedMessage list to storage\n\t *\n\t * @param message - A Message that will replace an existing Message (with the id) in this.messages\n\t */\n\tprotected updateMessage(message: M) {\n\t\tconst index = this.messages.findIndex((msg) => message.id === msg.id);\n\t\t/* istanbul ignore next */\n\t\tif (index !== -1) {\n\t\t\tthis.messages[index] = message;\n\t\t}\n\t\tthis.saveMessageList();\n\t}\n\n\t/**\n\t * EventEmitter instance used to listen to specific message events\n\t */\n\thub = new EventEmitter();\n\n\t/**\n\t * Name of this controller used during composition\n\t */\n\tname = 'AbstractMessageManager';\n\n\t/**\n\t * Creates an AbstractMessageManager instance\n\t *\n\t * @param config - Initial options used to configure this controller\n\t * @param state - Initial state to set on this controller\n\t */\n\tconstructor(config?: Partial<BaseConfig>, state?: Partial<MessageManagerState<M>>) {\n\t\tsuper(config, state);\n\t\tthis.defaultState = {\n\t\t\tunapprovedMessages: {},\n\t\t\tunapprovedMessagesCount: 0\n\t\t};\n\t\tthis.messages = [];\n\t\tthis.initialize();\n\t}\n\n\t/**\n\t * A getter for the number of 'unapproved' Messages in this.messages\n\t *\n\t * @returns - The number of 'unapproved' Messages in this.messages\n\t *\n\t */\n\tgetUnapprovedMessagesCount() {\n\t\treturn Object.keys(this.getUnapprovedMessages()).length;\n\t}\n\n\t/**\n\t * A getter for the 'unapproved' Messages in state messages\n\t *\n\t * @returns - An index of Message ids to Messages, for all 'unapproved' Messages in this.messages\n\t *\n\t */\n\tgetUnapprovedMessages() {\n\t\treturn this.messages\n\t\t\t.filter((message) => message.status === 'unapproved')\n\t\t\t.reduce((result: { [key: string]: M }, message: M) => {\n\t\t\t\tresult[message.id] = message;\n\t\t\t\treturn result;\n\t\t\t}, {}) as { [key: string]: M };\n\t}\n\n\t/**\n\t * Adds a passed Message to this.messages, and calls this.saveMessageList() to save\n\t * the unapproved Messages from that list to this.messages.\n\t *\n\t * @param {Message} message The Message to add to this.messages\n\t *\n\t */\n\taddMessage(message: M) {\n\t\tthis.messages.push(message);\n\t\tthis.saveMessageList();\n\t}\n\n\t/**\n\t * Returns a specified Message.\n\t *\n\t * @param messageId - The id of the Message to get\n\t * @returns - The Message with the id that matches the passed messageId, or undefined\n\t * if no Message has that id.\n\t *\n\t */\n\tgetMessage(messageId: string) {\n\t\treturn this.messages.find((message) => message.id === messageId);\n\t}\n\n\t/**\n\t * Approves a Message. Sets the message status via a call to this.setMessageStatusApproved,\n\t * and returns a promise with any the message params modified for proper signing.\n\t *\n\t * @param messageParams - The messageParams to be used when signing method is called,\n\t * plus data added by MetaMask\n\t * @returns - Promise resolving to the messageParams with the metamaskId property removed\n\t */\n\tapproveMessage(messageParams: PM): Promise<P> {\n\t\tthis.setMessageStatusApproved(messageParams.metamaskId);\n\t\treturn this.prepMessageForSigning(messageParams);\n\t}\n\n\t/**\n\t * Sets a Message status to 'approved' via a call to this.setMessageStatus.\n\t *\n\t * @param messageId - The id of the Message to approve\n\t */\n\tsetMessageStatusApproved(messageId: string) {\n\t\tthis.setMessageStatus(messageId, 'approved');\n\t}\n\n\t/**\n\t * Sets a Message status to 'signed' via a call to this.setMessageStatus and updates\n\t * that Message in this.messages by adding the raw signature data of the signature\n\t * request to the Message.\n\t *\n\t * @param messageId - The id of the Message to sign\n\t * @param rawSig - The raw data of the signature request\n\t */\n\tsetMessageStatusSigned(messageId: string, rawSig: string) {\n\t\tconst message = this.getMessage(messageId);\n\t\t/* istanbul ignore if */\n\t\tif (!message) {\n\t\t\treturn;\n\t\t}\n\t\tmessage.rawSig = rawSig;\n\t\tthis.updateMessage(message);\n\t\tthis.setMessageStatus(messageId, 'signed');\n\t}\n\n\t/**\n\t * Removes the metamaskId property from passed messageParams and returns a promise which\n\t * resolves the updated messageParams\n\t *\n\t * @param messageParams - The messageParams to modify\n\t * @returns - Promise resolving to the messageParams with the metamaskId property removed\n\t */\n\tabstract prepMessageForSigning(messageParams: PM): Promise<P>;\n\n\t/**\n\t * Sets a Message status to 'rejected' via a call to this.setMessageStatus.\n\t *\n\t * @param messageId - The id of the Message to reject.\n\t */\n\trejectMessage(messageId: string) {\n\t\tthis.setMessageStatus(messageId, 'rejected');\n\t}\n}\n\nexport default AbstractMessageManager;\n"]}